# LiveAmonth
1. 프로그램 기획

 최근 화제가 되고 있는 한달 살기라는 주제로 프로그램을 기획했으며, 설문조사 결과 10명중 8명은 살아보는 여행을 꿈꾸고, 15일 이상의 장기 여행을 선호했습니다. 또한 비용을 한달살기의 고민거리로 응답하였고, 직접 한달살기를 경험한 사람들에게 질문한 결과, 자연경관이 좋은 곳에서 휴식하는 것과 나를 위한 시간을 보내는 것을 한달 살기를 시작했던 이유라고 말했습니다.
  한달살기 도중에는 주로 주변 여행지를 다니거나, 자연속에서 휴식을 즐기며, 지역의 특색에 관련된 활동이 주가 되었으며 대한민국 내에서 한달 살기를 하고싶은 지역을 조사한 결과 제주가 앞도적으로 높은 응답을 보였지만, 전국 곳곳의 여행지도 선호가 되었습니다. 마지막으로, 설문을 통해 저희가 고려해야 할 점은 여행정보와, 비용, 전국적인 지역이었습니다. 따라서 경쟁사이트를 언어, 지역, 여행정보제공, 커뮤니티, 비용계산 측면을 분석해보았고, 결론적으로 모두 만족시키는 사이트는 없었습니다.
 LiveAmonth 사이트는 사용자들이 원하는 핵심 요소를 장소, 비용, 계획 세가지라고 판단했습니다. 즉, 스스로 의미있는 시간을 보내고, 충분히 휴식을 하기 위해서는 한달 살기를 하는 장소, 생활하는 비용과 한달살기 기간 동안의 생활을 계획하는 것 이 세가지 측면 모두가 중요하다고 판단했습니다. 따라서 프로그램 요구사항으로 각 핵심요소에 맞게 사이트의 메인 기능을 정했습니다. 장소를 위해 여행지를 점수화 하여 직관적으로 표시하고, 각 지역별로 유명한 관광정보를 정리하고, 비용을 위해 개인 별 한달 살기 비용을 업로드하며, 서로 원하는 조건을 선택해 확인 할 수 있게 하고, 계획을 위해 공유 가능한 캘린더 작성 기능을 기획했습니다.
 
 프로그램 개발 과정의 경우, 앞서 정한 사이트의 메인 기능을 전체 프로덕트로 선정하고 에자일 방식을 적용하여 1주일을 스프린트 기간으로 두어 개발을 진행하였습니다. 주제 선정과 기획을 시작으로, 기능 요구사항을 정리하고, 각 메인 기능을 하나씩 개발해나가며 주에 한번 메인 회의, 필요할 때 마다 긴급 회의로 버그를 고치거나 세부 기능을 추가하며, 회의 내용을 바로 프로그램에 적용하는 유연한 개발 과정으로 liveAmonth는 탄생했습니다.
 프로그램 메인 기능은 크게 4가지가 존재합니다. city, schedule, review, myPage & 고객센터 입니다.
  
  ①city
  
  city의 경우 liveAmonth가 선정한 전국의 한달 살기 추천 도시를 안내합니다. 서울, 강릉, 경주, 부산, 여수, 제주 총 6개의 대표적인 도시로 구성되어있으며, 각 도시의 간략한 설명, 유명한 볼거리와 먹을거리들을 소개합니다. 또한 정류장 및 노선 개수를 바탕으로 알고리즘을 사용해 점수화한 교통 정보를 제공해 교통 편의성을 나타내며, 전년도 기온 정보를 제공해 대략적인 기온 예측을 도와줍니다.
  
  ② schedule
  
  schedule의 경우 한달 살기 계획을 작성하거나, 한달 살기 기록을 할 수 있는 캘린더를 제공합니다. 사용자들은 자신의 일정을 도시 별로 캘린더에 등록하고, 사용한 비용을 기록 할 수 있습니다. 또한, 필터 기능을 만들어 사용자가 관심있는 주제를 더욱 직관적으로 제공받을 수 있게 하였습니다. 또한 캘린더를 작성해서 다른 사용자와 공유가 가능하도록 하였으며, 이때, 다른 사용자의 캘린더를 원하는 성별, 나이대 와 관심있는 도시로 추천순, 최신순, 조회순으로 검색을 가능하게 했습니다. 또한 좋아요와 댓글기능도 추가하였기 때문에 마음에 드는 일정은 추천을 누르고, 궁금한 사항이 있으면 해당 일정 작성자에게 댓글로 질문을 할 수 있고, 작성자는 대댓글 기능으로 답변이 가능합니다.
  
  ③ review
  
  review는 liveAmonth의 커뮤니티 기능을 담당하고 있습니다. liveAmonth는 사용자가 만들어내는 경험 데이터를 공유하여 더 가치 있는 데이터를 만들어내는 부분에 집중하였습니다. 단순히 홈페이지 내에서 제공하는 정보보다는, 사이트 사용자가 서로 커뮤니케이션을 통해 의미있었던 활동과, 자신의 순수 경험을 공유하는 측면을 긍정적으로 강조하였습니다. 
  각 게시판을 통해 사용자들은 주제별, 도시별로 각자의 경험을 게시글로 작성할 수 있게 하였고, 좋아요 및 댓글 기능 또한 포함시켜 커뮤니티적 측면을 살렸습니다. 이외에도 시간순, 조회수순, 좋아요 순등의 정렬 기능과 검색기능을 추가하여 직관성을 살렸습니다. 
 review의 기능으로 인해 사용자 기반 데이터가 사이트에 점차 축적되며, 다양하고 진솔한 경험 데이터가 liveAmonth의 중심을 이룰 것 입니다. 
    
 ④ myPage
 
 myPage에서는 사용자 자신의 회원정보 확인 및 수정을 할 수 있습니다. liveAmonth는 각 사용자를 중요시 하기 때문에, 프로필 또한 단순한 이름이 아닌 닉네임, 프로필 사진 등 자유롭게 자신을 표현할 수 있는 기능을 추가하였습니다. 또한 커뮤니티에서 자신이 작성한 게시글을 간편하게 확인할 수 있게 하였고, 편의를 위해 1:1문의 기능을 추가하였습니다. 또한, liveAmonth는 사용자 편의를 위해 네이버 연동 로그인을 도입하여 회원가입을 약식으로 할 수 있게끔 기능을 제공하여 사용자의 편리성을 더욱 증대시켰습니다.

 ⑤ 고객센터
 
 고객센터에서는 회원의 데이터를 관리하기 때문에 개인정보 처리방침과 이용약관을 직접 개인 정보보호포털을 사용해 작성하였으며, 공지사항과 FAQ 기능으로 좀 더 편리하게 리버먼스 사이트를 사용 할 수 있도록 하였습니다. 

2. 아키택트

① 웹 서버

 liveAmonth의 웹 서버는 아마존 elastic beanstalk을 사용해 EC2 기반의 웹서버를 간편하게 구축하였습니다. elastic beanstalk는 개발된 웹 애플리케이션 및 서비스를 간편하게 배포, 조정 할 수 있는 서비스이며, 이를 사용해 애플리케이션 작성에만 집중을 할 수 있게되서 생산성을 향상시키는데 많은 도움을 받았습니다.
  elastic beanstalk 서비스에 설정된 서버 구조의 경우, load balancer가 웹 서버인 EC2 인스턴스를 
auto-scaling 그룹으로 묶어 관를 하도록 설정했습니다. 이 구조의 장점은 먼저 로드 밸런싱을 통해 여러 대의 서버가 분산 처리되서 서버의 부하를 줄일 수 있습니다. 또한, auto-scaling을 사용하기 때문에 현재 존재하는 웹서버의 사이즈를 조절하여, 서버의 트래픽이 집중될 때, 서버 사이즈를 늘리고, 비교적 트래픽이 한산할 때는 서버 사이즈를 줄여 탄력적인 운영이 가능하며, 비용 절감의 효과도 있습니다. 추가적으로 DB는 아마존 RDS 서비스를 사용하고 있으며, S3 Bucket을 사용해 사이트의 애플리케이션 버전과 사이트에서 사용되는 이미지를 저장해 애플리케이션의 크기를 줄였습니다. 

② CI/CD
 liveAmonth는 자동배포를 위해 jenkins를 사용했습니다.
 개발자가 github에 코드를 push하면, github에서 jenkins로 연결된 레파지토리에 작업이 수행되었다고 webhook을 날립니다. 그러면 jenkins에서는 레파지토리에 있는 소스를 .war 파일로 빌드 후, s3에 업로드 합니다. 이후 최종적으로, elastic beanstalk에 deploy 명령을 내려 서비스에서 s3에 업로드 된 파일을 받아 서버에 배포를 합니다.
 
③ 업데이트 시 배포 정책
 저희 서버에서는 Rolling 방식으로 업데이트 된 애플리케이션을 배포합니다. 롤링방식이란 서버를 한 대씩 구버전에서 새 버전으로 교채합니다. 즉, 서비스 중인 서버  한 대를 제외시키고 그 자리에 새 버전의 서버를 추가합니다. 이후 남은 서버도 마찬가지로 인스턴스를 중지 후, 버전을 변경합니다. 그래서 이러한 방식을 통해 트래픽을 점진적으로 전환합니다.

④ 사용 환경 및 코드 설명

 a. 저희 팀에서는 java를 기반으로 스프링 프레임워크를 사용하여 디자인 패턴을 적용했습니다. 프로젝트 전반적으로 IDE는 인텔리제이를 사용했으며, DB는 데이터그립과 워크벤티를 혼용했습니다. 
 View 부분은 jsp언어로 jquery, bootstrap 등 여러 오픈소스 라이브러리를 사용했으며, db는 mysql를 사용했으며 SQL작성을 위해 myBatis를 사용했습니다.
  디자인 패턴의 경우 spring MVC를 사용했으며, Model, View, Controller로 구성이 되어있습니다. 이때, 사용자가 데이터를 요청하면 front controller에서 매핑을 통해 알맞은 컨트롤러를 호출하게 되고, 컨트롤러에서 내부 로직이 담긴 model 호출하여 내부로직을 수행하게 됩니다. 이후, 데이터를 가져와 가공 및 처리를 수행 한 뒤, 데이터를 view Resolver가 view에 데이터를 pulishing을 해줍니다.
  
 b. 각 층에서 사용된 오픈 소스 및 코딩 기법에 대해서 설명하자면, presentation layer에서는 JSP페이지 소스의 가동성을 높이고 유지 보수성을 향상시키기 위해 JSTL을 사용했으며, 비동기식 서버통신인 AJAX를 사용하기 위해 JSON을 사용해 화면 전환없이 데이터를 주고 받을 수 있게 했습니다. 또한, 웹 페이지에 headr와 footer 같은 반복 레이아웃을 한 곳에서 관리할 수 있도록 tiles framework를 사용했습니다.

c. control, business logic layer의 경우 리팩토링을 최대한으로 하기 위한 코딩 스타일을 적용했습니다. 첫번째 방법으로는 전체 코드 내에 상수에 대해 constant package를 만들어 enum 클래스를 사용해 한 곳에서 관리를 했습니다. 사용되는 메시지, 파일 이름 등 고정적인 상수에 대해 변경이 있더라도 전체 코드를 고치는 것이 아닌, 만들어둔 constant package의 enum클래스의 값만 변경해 사용할 수 있도록 했습니다.
 두번째 방법으로는 컨트롤러에서 사용되는 중복 매서드를 일반화하여 하나의 부모 클래스를 생성했습니다. 이로인해 코드의 가독성을 높이는 효과를 보였습니다.
 세번째 방법으로는 각 layer 사이 인터페이스 타입을 사용했습니다. 인터페이스 타입을 사용하게 되면 객체의 교환성이 높아져 컴퓨터의 부품을 교체하듯이 변경점이 있다면 해당 인터페이스의 구현체만 바꾸어 사용할 수 있어서 유지보수성이 향상됩니다.
 마지막으로 저희 프로젝트에서는 myBatis를 사용해 DB에 접근을 했습니다. 이 방법으로 소스코드와 SQL을 분리하여 사용가능 했고, SQL의 세부적인 내용 변경에 유리했으며 동적 쿼리 사용시 JAP와 같은 ORM에 비해 간편하게 구현이 가능했습니다.

⑤ 애플리케이션 관리 툴

 저희는 앞서 말했다 싶이 agile을 기반으로 프로젝트에 임했습니다. 그래서 전체 프로덕트와 스프린트 및 진척도를 관리 하기 위해 redmine을 사용했으며, gitHub를 이용하여 소스코드를 통합하며, jenkins를 통해 자동 배포를 했습니다.
 
⑥ DB Design

DB의 경우 정보 제공 및 사용자 간의 의사소통 및 사용자 중심 일정 작성이 핵심 기능이기 때문에, 복잡한 비즈니스 로직보다는 입출력 구조가 더 많이 존재해 OR Mapping이 아닌, SQL Mapping을 적용했습니다. 그리고 이에 따라, RDBMS를 기반으로 DB를 구축하였으며, 각각의 entity에 대한 관계들을 도출하기 위해 비즈니스에 대해 사전 조사 및 시스템 분석을 진행하였습니다. 그리고 이러한 분석 결과를 기반으로 conceptual modelling을 E-R DIAGRAM으로 작성했습니다. 이후, conceptual Design을 기반으로, logical Design을 진행하였고, 이때, 테이블을 정의하고 각각의 테이블에 대한 PK와 FK를 정의했습니다. 마지막으로 이 logical Design을 기반으로 physical Design을 수행했으며, 각 속성의 형식, 순서, 접근 경로와 같은 정보를 결정하고 작성을 하였습니다. 그리고 이 모든 과정은 거친 뒤, 3rd normalization에 만족하였는지 확인했으며, 필요에 따라 반 정규화 역시 수행할 예정입니다.
Table 들의 관계 및 속성들이 모두 정의된 이후, 데이터 추출 시, 트레픽 과부하를 최소화하기 위해, 쿼리문을 최대한 깨끗하게 작성하려고 노력하고 있으며, 예를 들어 한 SQL 스테이트먼트가 한 테이블에서 하나, 혹은 두 개의 필드를 선택하고 다른 SQL 스테이트먼트가 이 정보를 이용해서 다른 테이블의 데이터를 가져온다면, 이 두 가지를 두 테이블에서 데이터를 돌려보내는 하나의 스테이트먼트로 작성하려고 노력했습니다. 그리고 JOIN 문이 많이 사용되는 TABLE 들의 경우, 현재 반 정규화를 고려하여 프로젝트를 진행 중에 있습니다.
